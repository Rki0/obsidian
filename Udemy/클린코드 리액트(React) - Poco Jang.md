# ⚠️주의
- 클린 코드 !== 좋은 코드. 클린 코드에 매몰되어 광적으로 따르지말자.
- 좋은 코드로 소개되는게 전부 다 나한테 적용될 수 있는 좋은 코드가 아님에 주의하자.
- 유명한 사람들의 코드라고 전부 맞는 것은 아니다. 항상 면밀하게 코드를 살피고 이해하자.
# State
## 올바른 초기값 설정
### 초기값
- 가장 먼저 렌더링 될 때 순간적으로 보여질 수 있는 값이기도 하다.
- 당연히 초기에 렌더링 되는 값
### 초기값을 지키지 않은 경우
- 렌더링 이슈, 무한 루프, 타입 불일치로 의도치 않는 동작 => 런타임 에러
- 넣지 않으면? undefined
- 상태를 CRUD => 상태를 지울 때도 초기값을 잘 기억해놔야 원상태로 돌아간다.
- 빈 값? null 처리를 할 때 불필요한 방어 코드를 줄여준다!
## 업데이트 되지 않는 값
### React에 연결되어 있는 값이 아니면 컴포넌트 외부로 빼내자
![[Pasted image 20240128160328.png]]
위 코드에서 `INFO`가 변하는 로직은 어디에도 없다.
문제는 컴포넌트 내부에 선언되어 있기 때문에 다양한 상황에서 참조로 인한 사이드 이펙트가 발생할 수 있다.
따라서, `INFO`는 React State로 변경하든가, 아예 외부로 내보내는게 좋다.
전자의 방법은 그렇게 좋은 해결법은 아닌 것 같고, 후자를 시도해 보면 아래와 같다.
![[Pasted image 20240128160541.png]]
같은 파일 내에 있기 때문에 참조 에러가 발생하지 않을 뿐더러,
`App`이라는 컴포넌트가 다시 트리거되고, 다시 마운트되고 등등..이기 때문에
`INFO`를 참조하기 위한 불필요한 사이드 이펙트를 제거할 수 있다.
#### 요약
- 업데이터가 되지 않는 일반적인 객체라면 React 외부로 내보내기
## 플래그 상태
### 플래그 값?
- 프로그래밍에서 주로 특정 조건 혹은 제어를 위한 조건을 불리언으로 나타내는 값
![[Pasted image 20240128161600.png]]
위 코드에서는 하나의 상태를 위한 플래그 값이 정말 다양하게 존재하고 있다.
그런데 굳이 이렇게 state로 관리할 필요가 없다.
![[Pasted image 20240128161818.png]]
이렇게 간단하게 변경하면, `hasToken`, `hasCookie`가 변했을 때, 다시 계산되면서 `isLogin`이 재평가 될 것이기 때문이다.
이렇게 플래그 값이 많을 때는 굳이 전부 state로 관리하려고 하지말고, 표현식 하나로 만들어보자.
#### 요약
- `useState` 대신 플래그로 상태를 정의할 수 있다.
## 불필요한 상태
- 초기값을 변경해야하는 경우, 값을 변경해야하는 경우 주로 발생하는 문제
![[Pasted image 20240128171735.png]]
위 코드는 `userList`가 변경될 때마다 `completed` 속성이 `true`인 것들만 `completedUserList`에 넣고자 하는 경우이다.
그런데, 특정 조건인 것들만 따로 모아보기 위해서 state를 사용하는 것은 불필요하다!
그냥 변수로 관리하면 된다. 너무 하드하게 setState를 하려고 하지말자.
![[Pasted image 20240128171657.png]]
### 요약
1. 특정 조건의 값을 필터링하기 위해 새로운 state를 생성해서 관리하지 말자.
2. 컴포넌트 내부 변수는 렌더링 때마다 고유한 값을 가진다.
## useState 대신 useRef
리렌더링 방지가 필요하다면 useState 대신 useRef를 사용해보자.
컴포넌트의 전체적인 수명과 동일하게 지속된 정보를 일관적으로 제공해야하는 경우에 좋다.
![[Pasted image 20240128172054.png]]
아래와 같이 코드를 변경하면, useEffect 로직에서 렌더링을 유발하지 않기 때문에 불필요한 렌더링 방지가 가능하다.
![[Pasted image 20240128172433.png]]
또한, useRef 값이 컴포넌트 수명 주기와 동일하게 진행되기 때문에 일관적인 값을 안전하게 제공할 수 있다.
꼭 DOM에 붙여서 사용하는 것만이 useRef의 전부가 아니라는 것을 기억하자!
### 요약
- useState 대신 useRef를 사용하면, 컴포넌트의 생명주기와 동일한, 리렌더링되지 않는 상태를 만들 수 있다
## 연관된 상태 단순화하기 / 연관된 상태 객체로 묶어내기
아래와 같은 상황을 가정해보자.
fetch가 시작되면 `isLoading`만 `true`일 것이 기대된다.
fetch가 성공하면 `isFinish`만 `true`일 것이 기대된다.
fetch가 실패하면 `isError`만 `true`일 것이 기대된다.
즉, 각 상황에 대하여 세 가지 state가 연관되어 있다는 것이다.
![[Pasted image 20240128180121.png]]
3가지의 상태를 따로 관리하지 않고 다음과 같은 방법을 사용해 볼 수 있겠다.
![[Pasted image 20240128181402.png]]
여러 개의 state를 관리하는 것으로 인한 복잡함을 훨씬 줄일 수 있다.
하나의 state 변경으로 인해 나머지 state를 그에 맞춰 동기화 해줘야 하는 상황을 보다 쉽게 처리할 수 있다.
state 자체를 객체로 관리하는 것도 좋다!
![[Pasted image 20240128191829.png]]
또한 `useReducer`를 사용해도 된다. 다양한 관점이 있구나 생각하는 정도로 살펴보자.
## useState에서 useReducer로 리팩터링
